---
pagetitle: "spatial operations with sf"
---

<br>

## Spatial Operations in R with `sf`

Many operations commonly done with ArcGIS or QGIS are joins based on some component of the spatial topology. For example, you want to figure out what attributes of certain points on the landscape fall into certain polygons on the landscape...like bus-stops in a county or river gaging stations within a watershed. This could be done with a spatial join based on the intersection between the points and the polygons, may include [specific options](https://r-spatial.github.io/sf/reference/geos_binary_pred.html) like *crosses*, *within*, *touches*, etc. The point being, we can do all this in R! 

Let's **load the libraries** we're going to need first.

```{r libseval, eval=T, echo=F, message=F, show=FALSE}

suppressPackageStartupMessages({
  library(here);
  library(dplyr);
  library(raster);
  library(spData);
  library(viridis);
  library(ggplot2);
  library(lubridate);
  library(leaflet);
  library(sf);
  library(mapview);
  library(USAboundaries) # STATES/counties data
})

```


```{r}

canterbury <- nz %>% filter(Name == "Canterbury")

plot(nz$geom, col="white", bgc="dodgerblue",
     col_graticule="gray",graticule=TRUE, axes=TRUE)

# spatial subset/join
canterbury_height <- nz_height[canterbury, ]
plot(canterbury_height$geometry, add=T, col="red")
# subsetting x[y, ] subsets features of a target x using the contents of a source object y

# anti_join
non_canter <- nz_height[canterbury, , op = st_disjoint]
# same as:
non_canter2 <- st_disjoint(canterbury, nz_height, sparse = TRUE)

class(non_canter2)
plot(non_canter$geometry, bg="forestgreen", pch=21, add=T)

# using filter
canterbury_height3 <- nz_height %>%
  filter(st_intersects(x = ., y = canterbury, sparse = FALSE))
plot(canterbury_height3$geometry, add=T, bg="gray", pch=22)

#st_is_within_distance(poly, point, dist = 0.9)

# anything touches?
# any(st_touches(cycle_hire, cycle_hire_osm, sparse = FALSE))
# cycle_hire_P = st_transform(cycle_hire, 27700) # projected CRS
# cycle_hire_osm_P = st_transform(cycle_hire_osm, 27700)
# sel = st_is_within_distance(cycle_hire_P, cycle_hire_osm_P, dist = 20) # within 20m of one another
# summary(lengths(sel) > 0)

# join 

# z = st_join(cycle_hire_P, cycle_hire_osm_P, st_is_within_distance, dist = 20)

regions = aggregate(x = us_states[, "total_pop_15"], by = list(us_states$REGION),
                    FUN = sum, na.rm = TRUE)
regions2 = us_states %>% group_by(REGION) %>%
  summarize(pop = sum(total_pop_15, na.rm = TRUE))


```

